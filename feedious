#!/usr/bin/env bash
#
# FEEDIOUS - (Feed + Invidious)
# A minha ideia para o desafio foi utilizar a API do invidious ao invés do próprio youtube.
# Tentei utilizar apenas Bash, porém precisei utilizar wget para as consultas de API.
# OBS: Não tratei muitos erros, mas acredito que fiz o principal
#
# José Almeida <jose.afga@gmail.com>

CONFIG_FILE='sources.conf'

# Limpa variaveis globais utilizadas
__reset() {
  unset URL PLAYER MAX_OPTION_LENGTH SEPARATOR channels _options
}

__exit() {
  __reset
  unset CONFIG_FILE

  exit $1
}

# Verifica se parametro passado e uma funcao
__is_function() {
  type -p $1 &>/dev/null
}

# Realiza a leitura e definicoes do arquivo de configuracao
__parse_config() {
  local config config_channels

  __reset
  mapfile -t config <"$CONFIG_FILE"

  for cfg in "${config[@]}"; do
    case "$cfg" in
      \#*) continue ;; # comentarios
      \[*\])
        config_channels='false'
        ;;&
      \[Channels\]) # comeco dos canais
        config_channels='true'
        ;;
      *=*)
        if [[ "$config_channels" == 'true' ]]; then
          declare -gA "channels[${cfg/=/]=}"
        else
          declare -g "$cfg"
        fi
        ;;
    esac
  done
}

# Exibe texto de carregamento
# TODO: criar algo mais interativo
loading() {
  printf $'%s\r' "Carregando..."
}

header() {
  unset _options # Limpa opcoes anteriores

  printf '%s\n' $SEPARATOR
  printf '%s\n' '     Feedious ▶️   '
  printf '%s\n' $SEPARATOR
}

#-------------------- OPTIONS --------------------#

# Adiciona e exibe uma opcao de menu
options_add() {
  local desc
  declare -gA _options["$1"]="$3"

  # Trunca textos grandes
  [[ ${#2} -gt ${MAX_OPTION_LENGTH:-99} ]] && desc="${2:0:${MAX_OPTION_LENGTH:-99}}..." || desc="$2"

  printf '%s\n' "[$1] $desc"
}

# Verifica se as opcoes foram definidas
# utilizasse antes de exibir o menu de opcoes para ter certeza que alguma opcao foi carregada
options_check() {
  [[ ${#_options[@]} -ne 0 ]] || {
    printf '%s\n' "Atenção: não foram encontradas opções."

    read -rt 5 # aguarda enter ou 5 segundos
    return 127
  }
}

# Faz a pergunta e associa com com as opcoes de menu (aceita inteiros apenas)
options_ask() {
  local -i answer

  options_check || return $?

  printf '%s' "$1"
  read -r answer

  # Verifica se valor informado esta dentro das opcoes
  if [[ -n "${_options[$answer]}" ]]; then
    __is_function "${_options[$answer]%% *}" &&
      ${_options[$answer]} ||
      printf '%s\n' "Erro: a função selecionada não foi encontrada." >&2
  else
    options_ask "Valor incorreto. Tente Novamente: "
  fi
}

#-------------------- CHANNELS --------------------#

channels_search() {
  local answer

  printf '%s' "Informe o termo de pesquisa: "
  read -r answer

  channels_list "$answer"
}

# Realiza a adicao do canal no arquivo de configuracao e recarrega
channels_add() {
  local config="$(<"$CONFIG_FILE")"
  local channel=$'[Channels]\n'
  channel="${channel}${@:1:1}=${@:2}"

  printf '%s' "${config/\[Channels\]/$channel}" >$CONFIG_FILE
  printf '%s\n\n' "Canal ${@:2} foi adicionao."

  __reset
  main
}

channels_list() {
  local endpoint="${URL}/api/v1/search?q=${1}&type=channel&fields=author,authorId,description"
  local response

  loading
  response=$(wget -qO- "$endpoint")

  channels_menu "$response"
}

# Analisa a reposta da API e gera menu de canais
channels_menu() {
  local -i count=0
  local json="$1"
  local regex='\"author\":\"([^\"]*)\",\"authorId\":\"([^\"]*)\",\"description\":\"([^\"]*)' # TODO: melhorar o regex

  header

  while [[ $json =~ $regex ]]; do
    # Concatena descricao caso exista
    [[ ${BASH_REMATCH[3]} ]] &&
      options_add "$((++count))" "${BASH_REMATCH[1]} - ${BASH_REMATCH[3]}" "channels_add ${BASH_REMATCH[2]} ${BASH_REMATCH[1]}" ||
      options_add "$((++count))" "${BASH_REMATCH[1]}" "channels_add ${BASH_REMATCH[2]} ${BASH_REMATCH[1]}"

    json="${json##*${BASH_REMATCH[0]}}" # Remove parte ja processada
  done

  options_add "0" "Cancelar" "main_menu"
  printf '%s\n' $SEPARATOR
  options_ask "Selecione uma opção: " || main_menu
}

#-------------------- VIDEOS --------------------#

videos_list() {
  local endpoint="${URL}/api/v1/channels/${1}/latest?fields=title,videoId"
  local response

  loading
  response=$(wget -qO- "$endpoint")

  videos_menu "$response"
}

# Abre URL com o player escolhido no arquivo de configuracao
videos_play() {
  $PLAYER "$URL/watch?v=$1"

  __exit
}

# Analisa a reposta da API e gera menu de videos
videos_menu() {
  local -i count=0
  local json="$1"
  local regex='\"title\":\"([^\"]*)\",\"videoId\":\"([^\"]*)' # TODO: melhorar o regex

  header

  while [[ $json =~ $regex && count -lt ${MAX_VIDEOS:-5} ]]; do
    options_add "$((++count))" "${BASH_REMATCH[1]}" "videos_play ${BASH_REMATCH[2]}"
    json="${json##*${BASH_REMATCH[0]}}" # Remove parte ja processada
  done

  options_add "0" "Cancelar" "main_menu"
  printf '%s\n' $SEPARATOR
  options_ask "Selecione uma opção: " || main_menu
}

#-------------------- MAIN --------------------#

main_menu() {
  local -i count=0

  header

  for i in "${!channels[@]}"; do
    options_add "$((++count))" "${channels[$i]}" "videos_list $i"
  done

  printf '%s\n' $SEPARATOR
  options_add "$((++count))" "Adicionar canal" "channels_search"
  options_add "0" "Sair" "__exit"
  printf '%s\n' $SEPARATOR
  options_ask "Selecione uma opção: "
}

main() {
  __parse_config
  if [[ -z "$PLAYER" ]]; then
    printf '%s\n' "Erro: nenhum player definido na configuração." >&2
    __exit 128
  fi

  main_menu
  __exit
}

main "$@"
